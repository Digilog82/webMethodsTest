// 파일이 모두 read 된 다음 drawChart 가 실행되어야 하는데 그 시점을 아는 방법이 파악되지 않아 일단 2초뒤 실행되게 하기 위해 아래의 변수를 설정
// 이와 같이 파일 선택 후 임의의 시간 뒤에 실행되게 하는 방법보다는, 선택된 전체 파일이 모두 읽힌 후 이벤트를 받아 차트가 생성되도록 수정되어야 함.
var timeout = 2000;

var indexArray1 = [0,0,0,0,0,0,0,0,0,0,0,0,0];
var indexArray2 = [0,0,0,0,0,0,0,0,0,0,0,0,0];

// 천단위로 콤마찍기
function commaFormatted(amount) {
    amount = '' + amount;
    
    var delimiter = ",";
    var a = amount.split('.',2);
    var d = a[1];
    var i = parseInt(a[0]);
    if(isNaN(i)) { return ''; }
    var minus = '';
    if(i < 0) { minus = '-'; }
    i = Math.abs(i);
    var n = new String(i);
    var a = [];
    while(n.length > 3) {
        var nn = n.substr(n.length-3);
        a.unshift(nn);
        n = n.substr(0,n.length-3);
    }
    if(n.length > 0) { a.unshift(n); }
    n = a.join(delimiter);
    if( ! d || (d && d.length < 1)) { amount = n; }
    else { amount = n + '.' + d; }
    amount = minus + amount;
    return amount;
}

// 끝에 있는 0 지우기: 1,234.5600 => 1,234.56
function removeLastZeros(str) {
    if ( ! str) {
        return;
    }
    
    str += '';  // 숫자가 오면 문자열로 바꾸기
    
    // . 이 포함되어 있지 않으면 하지 않음
    if ( ! str.match(/\./)) {
        return str;
    }
    
    while ((str.substr(str.length - 1) == 0 || str.substr(str.length - 1) == '.') && str) {
        var lastLetter = str.substr(str.length - 1);
        str = str.substring(0, str.length - 1);
        
        if (lastLetter == '.') {
            break;
        }
    }
    
    return str;
}

// mathjs 를 사용해서 소수점 8째자리까지 표시되는 값으로 계산
function numberFormat(value) {
    var value = math.eval('' + value),
        options = {
            notation: 'fixed',
            precision: 1    // 소수점 첫째자리까지 표시
        },
        result;
    
    result = math.format(value, options);
    
    
    // 콤마표시
    result = commaFormatted(result);
    
    // 맨 뒤의 0들 지우기
    result = removeLastZeros(result);
    
    return result;
}

// Date : 날짜 
// Time : 시간 (분 단위로 찍힘) 
// JVMTotalMem (Total Memory)  : JVM 에서 사용하고 있는 메모리 (실제 Heap의 max와는 다름)
// JVMFreeMem (Free Memory) : JVM이 사용 가능한 메모리
// CurrentThreads (Current Service Threads) : 현재 활성화된 thread 수
// MaxThreads (Peak/Max Service Threads)  : 현재까지 서버에서 활성화된 바 있는 system thread 최대 수
// SSNs (Current Sessions) : 현재 활성화되어 있는 session 수
// SSNx (Peak Sessions) : 현재까지 서버에서 활성화되었던 최대 세션 수
// SSNAvg (Average Sessions) : 세션의 유효 기간 평균값
// REQs (Current Average request time) : 현재 실행 중인 서비스 요청 수
// REQx : 마지막 폴링 주기(1분) 사이의 서비스 평균 요청 수
// REQAvg : 마지막 폴링 주기(1분) 사이의 서비스 평균 실행 시간
// StartReq : 마지막 폴링 주기(1분) 사이에 시작한 서비스 요청 수
// EndReq : 마지막 폴링 주기(1분) 사이에 종료된 서비스 요청 수



var json = {};
var categoryList = ["totalMem", "freeMem", "currentThreads", "maxThreads", "sSNs", "sSNx", "sSNAvg", "rEQs", "rEQx", "rEQAvg", "startReq", "endReq" , "usedMem"];
var jsa = new Array(categoryList.length);
var maxMem ;
var chart;
var chkNo = 0;

function getURLParameter(name) {
  return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.search)||[,""])[1].replace(/\+/g, '%20'))||null;
}

function setup_reader(file) {
  var name = file.name;
  var reader = new FileReader();
  
  // get max memory value 
  maxMem =getURLParameter('maxMem');
  
  reader.onload = function(e) {
    chkNo = 0;
    var text = e.target.result;
    var lines = text.split(/[\r\n]+/g);
    
    for(var i = 0; i< lines.length; i++){
      if (lines[i].indexOf("Start")==-1 && lines[i].indexOf("TotalMem")==-1 && lines[i]!="") {
        var arrCols = lines[i].split(" ");
        
        for(var j=0;j<categoryList.length-1;j++){
          var temp1 = arrCols[0].split('-');
		  var temp2;
		  if(arrCols.length > 1){
		  
			temp2 = arrCols[1].split(':');
            if(temp1.length > 2 && temp2.length > 2){
				jsa[j].push({ 
            "x"   : new Date(temp1[0], parseInt(temp1[1], 10) - 1, temp1[2], temp2[0], temp2[1], temp2[2])
            ,"y"  : parseInt(arrCols[j+3], 16)
//              ,"name"   : categoryList[i]
				});
			}
		  }
        }
        
        var temp1 = arrCols[0].split('-');
		var temp2;
		if(arrCols.length > 1){
			temp2 = arrCols[1].split(':');
        //calculate used Mem
			maxMem = (maxMem==null) ? arrCols[3]: maxMem; 			
			if(temp1.length > 2 && temp2.length > 2){
				jsa[categoryList.length-1].push({ 
			  //"x"   : new Date(arrCols[0] + " " + arrCols[1]) // (new Date(arrCols[0] + " " + arrCols[1]).getTime()/1000)
			  "x"   : new Date(temp1[0], parseInt(temp1[1], 10) - 1, temp1[2], temp2[0], temp2[1], temp2[2])
			  ,"y"  : parseInt(arrCols[3],16) - parseInt(arrCols[4], 16)  // totalMem - freeMem
	//            ,"name"   : categoryList[i]
				});
			}
		}
      }
    }

    var jsonTemp = {};
    for(var i=0;i<categoryList.length;i++){
      jsonByField=  {};
      jsonByField["name"] =categoryList[i];
      jsonByField["dataPoints"] = jsa[i];
      jsonByField["type"] = "line";
      jsonByField["showInLegend"] =  "true";
      jsonByField["xValueType"] = "dateTime";
      
      jsonTemp[categoryList[i]] = jsonByField;
    }
    json["Stats"] = jsonTemp;
    
  }
  reader.readAsText(file, "UTF-8");
}

$(function() {
  var colorList = [
    "#2F4F4F",
    "#2F4F4F",
    "#008080",
    "#008080",
    "#2E8B57",
    "#2E8B57",
    "#3CB371",
    "#3CB371",
    "#90EE90",
    "#90EE90",
    "#4661EE",
    "#4661EE",
    "#EC5657",
    "#EC5657",
    "#1BCDD1",
    "#1BCDD1",
    "#8FAABB",
    "#8FAABB",
    "#B08BEB",
    "#B08BEB",
    "#3EA0DD",
    "#3EA0DD",
    "#F5A52A",
    "#F5A52A",
    "#23BFAA",
    "#23BFAA",
    "#FAA586",
    "#FAA586",
    "#EB8CC6",
    "#EB8CC6"
  ];
      
  // 범례 생성
  createLegend(categoryList, colorList);

  // chart상에 출력할 json 데이터 파일 선택
  $("#statfiles").change(function() {
    // reset json array
    for (var i = 0; i < categoryList.length; i++ ) {
      jsa[i] = new Array();
    } 

    // read stats files
    var statfiles = this;
    if ('files' in statfiles) {
      if (statfiles.files.length == 0) {
        alert("Please browse for one or more files.");
//      }else if(statfiles.files.length>7){
//        alert("Please select files less then 7.");
      } else {
        files = statfiles.files;
        
/*            var files = [].slice.call(statfiles.files);
          files.sort();
 */         
        for (var i = 0; i < files.length; i++) { 
          setup_reader(files[i]);
        }
      }
      indexArray1 = [0,0,0,0,0,0,0,0,0,0,0,0,0];
      indexArray2 = [0,0,0,0,0,0,0,0,0,0,0,0,0];
    }
    
    // 범례 초기화
    $('.legend').find('input').each(function() {
      this.checked = false;
    });
    
    indexArray1 = [0,0,0,0,0,0,0,0,0,0,0,0,0];
    indexArray2 = [0,0,0,0,0,0,0,0,0,0,0,0,0];

    // 차트 컨테이너 비우기
    $('#myChart').empty();
    
    // 차트 생성
    setTimeout(function() {
      drawChart();
    }, timeout);
  });

  // 차트 생성 함수
  function drawChart() {
    var chartData = [];

    for ( var i in categoryList) {
      
      // sort datapoints with x value 
      var dps = [].slice.call(json.Stats[categoryList[i]].dataPoints);
      var sorted = dps.sort(function (a, b) {
          return (a.x < b.x) ? -1 :1 ;
      });

      var yValues = [categoryList[i]];
      _.each(sorted, function(arg){
        yValues.push(arg.y);
      });
    
      chartData.push(yValues);
      
      // 오른쪽 Y축을 위한 데이터 생성
      var newArr = [];
      _.each(yValues, function(arr, i) {
        if (i == 0) {
          newArr.push(yValues[i] + '(오른쪽)');
        } else {
          newArr.push(yValues[i])
        }
      });
      chartData.push(newArr);
    }
    var xValues = ["Date"];
    _.each(sorted,function(arg){
      xValues.push(arg.x);
    });

    chartData.unshift(xValues);
    
    var transposeData = d3.transpose(chartData);

    // var data = [["name1", "city1", "some other info"], ["name2", "city2", "more info"]];
    var csvContent = "";
    transposeData.forEach(function(infoArray, index){

       dataString = infoArray.join(",");
       csvContent += index < transposeData.length ? dataString+ "\n" : dataString;

    }); 
    
    // 차트 생성
    chart = new Dygraph(
        document.getElementById("myChart"),
        csvContent,
        {
          colors: colorList,
          labelsSeparateLines: true,
          title: 'Log Analysis',
          series: {
            'totalMem(오른쪽)': {
              axis: 'y2'
            },
            'freeMem(오른쪽)': {
              axis: 'y2'
            },
            'currentThreads(오른쪽)': {
              axis: 'y2'
            },
            'maxThreads(오른쪽)': {
              axis: 'y2'
            },
            'sSNs(오른쪽)': {
              axis: 'y2'
            },
            'sSNx(오른쪽)': {
              axis: 'y2'
            },
            'sSNAvg(오른쪽)': {
              axis: 'y2'
            },
            'rEQs(오른쪽)': {
              axis: 'y2'
            },
            'rEQx(오른쪽)': {
              axis: 'y2'
            },
            'rEQAvg(오른쪽)': {
              axis: 'y2'
            },
            'startReq(오른쪽)': {
              axis: 'y2'
            },
            'endReq(오른쪽)': {
              axis: 'y2'
            },
            'usedMem(오른쪽)': {
              axis: 'y2'
            }
          },
          labelsDivStyles: {
            'border': '1px solid #333',
            'padding': '5px 0px 5px 20px',
            'z-index': 100
          },
          axes: {
            y: {
              axisLabelFormatter: function(d, gran, opts) {
                return numberFormat(d);
              },
              valueFormatter: function(y) {
                return numberFormat(y);
              },
              axisLabelWidth: 100
            },
            y2: {
              axisLabelFormatter: function(d, gran, opts) {
                return numberFormat(d);
              },
              valueFormatter: function(y) {
                return numberFormat(y);
              },
              axisLabelWidth: 100
            }
          },
          interactionModel : {
            'mousedown' : downV3,
            'mousemove' : moveV3,
            'mouseup' : upV3,
            'click' : clickV3,
            'dblclick' : dblClickV3,
            'mousewheel' : scrollV3
          },
          drawCallback: function(chart) {
            recolorlabels();
          }
        }
      );
      
    // 차트 생성 직후 가리기
    _.each(categoryList, function(category, i) {
      chart.setVisibility(i, false);
      chart.setVisibility(categoryList.length + i, false);
    });
  };
  
  // 범례 생성 함수
  function createLegend(categoryList, colorList) {
    var container1 = $('#legend1'),
      html1 = '',
      container2 = $('#legend2'),
      html2 = '';
    
    _.each(categoryList, function(category, i) {
      html1 += '<li><label><input type="checkbox"> <span class="color-box" style="background-color:' + colorList[i * 2] + ';"></span> ' + category + '</label></li>';
      html2 += '<li><label><input type="checkbox"> <span class="color-box" style="background-color:' + colorList[i * 2] + ';"></span> ' + category + '</label></li>';
    });
    
    container1.html(html1);
    container2.html(html2);
  }
  
  // 왼쪽 Y축 범례 클릭
  $('#legend1').on('click', 'input', function() {
    var checked = this.checked,
    li = $(this).closest('li'),
    index = li.index();

    if (checked == true) {
      chkNo = chkNo + 1;
      if (chkNo == 1) {
        chart.setVisibility(index * 2, checked);
        indexArray1[index] = 1;
        $(".dygraph-axis-label-y1").css("color",colorList[index*2]);
        $(".dygraph-axis-label-y2").css("color","#000");
        $(".dygraph-axis-label-y2").css("opacity",0); 
      } else if (chkNo == 2) {
        chart.setVisibility(index * 2+1, checked);
        indexArray2[index] = 1;
        var noOne = 0;
        for (var i=0;i<indexArray1.length;i++) {
          if (indexArray1[i] == 1) {
            noOne = i;
          }
        }
        $(".dygraph-axis-label-y1").css("color",colorList[noOne*2]);
        $(".dygraph-axis-label-y2").css("opacity",1); 
        $(".dygraph-axis-label-y2").css("color",colorList[index*2]); 
      } else {
        chart.setVisibility(index * 2, checked);
        indexArray1[index] = 1;
        var noTwo = 0;
        for (var i=0;i<indexArray2.length;i++) {
          if (indexArray2[i] == 1) {
            noTwo = i;
          }
        }
        $(".dygraph-axis-label-y1").css("color","#000");
        $(".dygraph-axis-label-y2").css("opacity",1); 
        $(".dygraph-axis-label-y2").css("color",colorList[noTwo*2]);
      }
    } else if (checked == false) {
      chkNo = chkNo - 1;
      
      if (indexArray1[index] == 1) {
        chart.setVisibility(index * 2, checked);
        indexArray1[index] = 0;
      } else if (indexArray2[index] == 1) {
        chart.setVisibility(index * 2+1, checked);
        indexArray2[index] = 0;
        $(".dygraph-axis-label-y2").css("color","#000"); 
        $(".dygraph-axis-label-y2").css("opacity",0); 
      }

      var noTwo = 0;
      for (var i=0;i<indexArray2.length;i++) {
        if (indexArray2[i] == 1) {
          noTwo = i;
        }
      }
      
      if (chkNo == 1) {
        if (noTwo == 0) {
          var noOne = 0;
          for (var i=0;i<indexArray1.length;i++) {
            if (indexArray1[i] == 1) {
              noOne = i;
            }
          }
          // console.log("d",noOne);
          $(".dygraph-axis-label-y1").css("color",colorList[noOne*2]);
          $(".dygraph-axis-label-y2").css("color","#000");
          $(".dygraph-axis-label-y2").css("opacity",0); 
        } else {
          indexArray1[noTwo] = 1;
          indexArray2[noTwo] = 0;
          chart.setVisibility(noTwo * 2, true);
          chart.setVisibility(noTwo * 2+1, false);
          $(".dygraph-axis-label-y1").css("color",colorList[noTwo*2]);
          $(".dygraph-axis-label-y2").css("color","#000");
          $(".dygraph-axis-label-y2").css("opacity",0); 
        }
      } else if (chkNo == 2) {
        if (noTwo != 0) {
          var noOne = 0;
          for (var i=0;i<indexArray1.length;i++) {
            if (indexArray1[i] == 1) {
              noOne = i;
            }
          }
          $(".dygraph-axis-label-y1").css("color",colorList[noOne*2]);
          $(".dygraph-axis-label-y2").css("opacity",1); 
          $(".dygraph-axis-label-y2").css("color",colorList[noTwo*2]);  
        } else {
          var noOnes = [];
          for (var i=0;i<indexArray1.length;i++) {
            if (indexArray1[i] == 1) {
              noOnes.push(i);
            }
          }
          indexArray1[noOnes[1]] = 0;
          indexArray2[noOnes[1]] = 1;
          chart.setVisibility(noOnes[1] * 2, false);
          chart.setVisibility(noOnes[1] * 2+1, true);
          $(".dygraph-axis-label-y1").css("color",colorList[noOnes[0]*2]);
          $(".dygraph-axis-label-y2").css("opacity",1); 
          $(".dygraph-axis-label-y2").css("color",colorList[noOnes[1]*2]);  
        }
      } else {
        $(".dygraph-axis-label-y1").css("color","#000");
        if (noTwo) {
          $(".dygraph-axis-label-y2").css("opacity",1); 
          $(".dygraph-axis-label-y2").css("color",colorList[noTwo*2]);
        } else {
          $(".dygraph-axis-label-y2").css("color","#000");
          $(".dygraph-axis-label-y2").css("opacity",0); 
        }
      }
    }

  });
  
  function recolorlabels() {
    var noOne = 0;
    var sumOne = 0;
    for (var i=0;i<indexArray1.length;i++) {
      if (indexArray1[i] == 1) {
        noOne = i;
        sumOne = sumOne + 1;
      }
    }
    if (sumOne ==0) {
      $(".dygraph-axis-label-y1").css("color","#000");
      $(".dygraph-axis-label-y2").css("color","#000");
      $(".dygraph-axis-label-y2").css("opacity",0); 
    }
    else if (sumOne == 1) {
      $(".dygraph-axis-label-y1").css("color",colorList[noOne*2]);
      $(".dygraph-axis-label-y2").css("color","#000");
      $(".dygraph-axis-label-y2").css("opacity",0); 
    }
    var noTwo = 0;
    for (var i=0;i<indexArray2.length;i++) {
      if (indexArray2[i] == 1) {
        noTwo = i;
      }
    }
    if (noTwo == 0) {
      $(".dygraph-axis-label-y2").css("color","#000");
      $(".dygraph-axis-label-y2").css("opacity",0); 
    } else {
      $(".dygraph-axis-label-y2").css("opacity",1); 
      $(".dygraph-axis-label-y2").css("color",colorList[noTwo*2]); 
    }
  };
  // 확대/축소 초기화
  $('#reset').on('click', function() {
    if (typeof chart != 'undefined') {
      restorePositioning(chart);
    }
  });
});
